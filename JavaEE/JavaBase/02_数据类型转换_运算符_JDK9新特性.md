# 第二节 数据类型转换、运算符、JDK 9新特性

## 一、数据类型转换

1. 分类：基本数据类型转换、引用数据类型(在后面章节仔细讲解)

2. 原因：Java程序中要求参与的计算的数据，必须保证数据类型一致性。如果数据不一致将发生类型的转换；
3. 注意事项：除了基本类型数据之间可以随意转换，引用类型类型一定要是父子类关系；

   **思考：基本类型的引用包装类型是否能随意转换？**

​	1）运算时，自动拆箱成对应的基本类型运算，类型转换参照基本类型数据转换；

​	2）运算后的基本类型数据，只能转换成对应的包装类型，不能随意转换成其他包装类，这就是引用类型转换特点，不是父子类，不随意转换；



下面讲解：基本数据类型的转换

### 1.1、 自动转换

```java
public static void main(String args){
    int i = 1;
    btye b= 2;
    //btye x = b + i;// 报错
    int j = b + i; // ok
}
```

上面就是一个自动转换的例子；

**转换原理：**

**1.  btye,char,short参与运算时，系统默认先转换成int，再进行计算。**

**2.  转换规则：byte,short,char ->int ->long -> float ->double**

```java
public btye test(){
    btye a = 121;
    btye b= 2;
    //return a-b; // 错误
    returun (btye)(a-b);//强转
}
```

### 1.2、 强制转换

```
int i = 1.5;// 错误
int i = (int)1.5;//强制转换
```

什么时候存在强制转换？将范围大的类型-->范围小的类型转换时，需要强转；

#####［强烈注意(在后面的运算中具体讲解)］

1. 浮点转成整数，直接取消小数点，可能造成数据损失精度；
2. int强制转成short，byte，char，会造成数据丢失；

### 1.3、 ASCII编码表 & Unicode编码表

为什么char字符型也能参与基本数据类型运算？是由于char其实也是一个对应的int类型在参与运算时，后再由int转换成对应的char; 这个对应关系表：参考Unicode编码表。 至于ASCII只是Unicode的部分编码表，可称为小表；

```
	int a = 1630000000;
     char c = (char) a;
     int d = c;
     System.out.println(c+"  "+d);
     ------------
     펀  54144 // a超出c的范围，经转换后造成数据丢失！
```

####综合题

```java
public static void main(String[] args) {
	short s = 1;
	int a = s+18; // 1. 正常转换，低级往高级
	
	int i = 10;
	short s1 = i+5; // 2. 有误，高级往低级，需要强转(高级占位多，无法容纳低位类型，所以自动转换只能是低->高，而不能高->低)
	
	char c1 = s+11; // 3. 有误，运算自动转化成int，再赋值发现是范围大-->范围小，需要强转
	
	final short s2 = 2;
	char c2 = s2+5; // 4. 正确，由于s2被final修饰，就是个常量，所以s2+5在编译过程，自动换算成常量7复制给c2;
  }
```



## 二、运算符

### 2.1、 分类

1. 算术运算符: +, -, *, /, %, ++, --, +字符串相加（字符串数据和任何数据使用+都是相连接，最终 都会变成字符串; （**注意：只有变量才能自增/自减，而常量不能自增/自减**）

2. 赋值运算符：=, +=, -=, *=, /=, %=;（**变量才能赋值，常量不能赋值**）

3. 比较运算符：==(相等于), !=(不等于), <(小于), >(大于), <=(小于等于), >=(大于等于), instanceof(检查是否是类的对象)。注意：比较运算符的结果都是 boolean 型，也就是要么是 true，要么是 false；比较运算符“==”不能误写成“=” 。;

4. 逻辑运算符：【& | ^]】、 【!  &&  ||】;

5. 位运算符：>> << >>>(无符号右移) &("与") ｜("或") ^("异或") ~("非")  
   3<<2=12 等价于 3*2的2次方=12；  00000011 --> 00001100  
   6>>2=1 等价于 6/2的2次方=1；  00000110 --> 00000001  
   3>>>1=1；  无论最高位是什么，右移后，都用 0 补,不管符号位，也就是说符号也右移；  

   -----------------------------------------------------------

   6&3=2；全部是1则为1，否则为0

   6|3=7；全部是0则为0，否为1

   6^3=5；相同就为0，不同为1

   ~6=-7；11111001 如何转换成十进制  10000111 不管符号位，答案：-7

   ```
   6&3 = 2;      6|3 = 7;      6^3=5;       ~6=-7；
    --------     --------     --------     -------- 
    00000110     00000110     00000110    ~00000110
   &00000011    |00000011    ^00000011
    --------     --------     --------     -------- 
    00000010     00000111     00000101     11111001 ---> 负数转换十进制：先取反，在+1  
                                           10000111 补码 －7
   ```

6. 转义字符：通过\ 来转变后面字母或者符号的含义。在 Linux 系统中换行是一个字符来 表示\n，windows 系统中，换行由\n\r 实现。\n:换行。\b:退格。相当于 backspace 键。\r: 按下回车键。\t:制表符。相当于 tab 键；

7. 三目运算符：格式： （条件表达式）？表达式 1：表达式 2；如果条件为 true，运算后的 结果是表达式 1；如果条件为 false，运算后的结果是表达式 2。如：获取两个数中大数，int x=3,y=4,z;z=(x>y)?x:y//z 变量存储的就是两个数的大数。

 ### 2.2、注意运算符的优先级顺序：

排序表不一定要记忆，只要记住（）先算即可！

```java
1. (),[]
2. +(正),-(负)
3. ++,--,! 自增、自减、非
4. *, /, % 
5. +(加),-(减) 
6. << ,>> ,>>>
7. >, >= ,<= 
8. ==, != 
9. &
10. ^
11. |
12. &&
13. ||
14. ? 三元运算
15. =,+=,-=,*=,/= 赋值
16. &=,|=, >>=, <<=, >>>= 位赋值运算
```

#####特列关注

```java
特例1：
=========================
int a = 1;
int b = 2;
System.out.println("a="+(++a)+",b="+(b++));
------------------------
a=2,b=2  // 特别注意，自增自减的方向，++a先自增再赋值，a++先赋值再自增；

特例2：
========================
byte a = 1;
a = a+1; // 编译错误，
a += 1; // 编译通过，使用复合赋值运算时，编译器会自动添加强转

特例3：
========================
System.out.println("5+5="+5+5);// 5+5=55 计算从左至右，【字符串】+5 依然是字符串 
```

### 2.3、运算时注意问题

**(1) 强转问题：**

```java
public byte count(byte b1,byte b2) {
	return (byte) (b1-b2); // 运算是int，所以最后要强转
}
----------------------

public byte count1() {
    byte a = 100; // 没有超出范围，编译自动添加强转，不需要显性强转
    byte b = (byte)130; // 超出范围，需要显性强转，那么这就会造成数据丢失问题
	return b++; // 不需要添加强转，复合运算，编译器会自带强转
}
----------------------
    
public int count2(int a,int b) {
	return a+b; // 为什么int没有超出范围概念？
}

public static void main(String[] args){
    int a = Integer.MAX_VALUE;
    int b = a + 1; // a＋1越界，不要强转
    System.out.println("a:"+a);
    System.out.println("b:"+b); 
    
    int c = Integer.MIN_VALUE;
    int d = c - 1;
    System.out.println("c:"+c);
    System.out.println("d:"+d);
}
-----------------
a:2147483647
b:-2147483648 // 答案却是负数了！
01111111 11111111 11111111 11111111 + 1 ＝
10000000 00000000 00000000 00000000(-2147483648)
    
c:-2147483648
d:2147483647 // 答案却是正数了！
10000000 00000000 00000000 00000000 - 1 = 
01111111 11111111 11111111 11111111   
```

根据分析，int之所以不要强转，是由于系统将符号位参与了运算，当超范围时，符号位进1。从而造成物极必反的效果，运算其实并没有错误，**只是出现了数据丢失现象**！

另外，计算机的数据存储采用**补码格式**：10000000 00000000 00000000 00000000就是-2147483648；

**相关知识：[源码，反码，补码]**

```
1. 正数的'反码'和'补码'都与原码相同。
2. 负数的'反码'为对该数的原码除符号位外各位取反。
3. 负数的'补码'为对该数的原码除符号位外各位取反，然后在最后一位加1　

正数：     189
源码：   0 10111101 // 最前面0代表符号，0为正，1为负
反码：   0 10111101 // 正数的反码就是本身
补码：   0 10111101 // 正数的补码就是本身

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
负数：     －189
源码：   1 10111101 // 最前面0代表符号，0为正，1为负
反码：   11111111 11111111 111111 01000010
补码：   11111111 11111111 111111 01000011 // 负数的补码就是本身先取反码，再＋1,符号位不变；
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
 System.out.println(Integer.toBinaryString(-189)); // 这个即打印出补码
 11111111 11111111 11111111 01000011
 
 例子: -2+3 = 1
   11111111 11111111 11111111 11111110
 + 00000000 00000000 00000000 00000011 (按数学计算，从低位到高位)
 --------------------------------------
  100000000 00000000 00000000 00000001 (最高位多余，主动舍去) 
 
```

**［重点：计算机为什么采用补码存储数据？因为使用补码存储后，所有的运算都是补码的&运算，即加法运算！］**



**(2) 精度流失问题：**

```java
public class MyJava {
    public static void main(String[] args) {
        int a = 3;
        double b = 0.03;
        double c = 0.03;
        double d = a+b+c;
        System.out.println("d:" + d); 
    }
} 
 ========
 d:3.0599999999999996
```

结果并不是我们预期的那样为3.06，其实double类型数值的计算经常会出现这种精度丢失的问题，尤其是有小数点的情况下，常常会应为精度丢失而导致程序出错。那么该如何解决这个问题呢？这时候我们需要使用位于java.math包中的BigDecimal类并用String来构造。

```java
public class MyJava {
    public static void main(String[] args) {
       	int a = 3;
        double b = 0.03;
        double c = 0.03;
        BigDecimal p1 = new BigDecimal(Double.toString(b));
        BigDecimal p2 = new BigDecimal(Double.toString(c));
        double d = a+(p1.add(p2).doubleValue());
        System.out.println("d:" + d); 
    }
} 
 ========
 d:3.06
```



## 三、JDK 9的新特性

### 3.1、 JShell 命令

什么时候会用到JShell工具？代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这时就可以使用JShell命令，其实JShell就是一个小脚本；

DOS下，直接输入JShell启动；

1. 是一个轻量级脚本；
2. 直接输入啥，执行啥，典型脚本的特点；
3. 退出/exit;

### 3.2、 编译器两点优化

1.  对于byte/short/char三种类型来说，如果右侧赋值没有超过范围，那么javac编译器会自动隐含为我们补上(byte)(short)(char)强制转换符；

   如果超过范围，则不会自动添加强转符，需要手动添加，但是会有数据丢失；

   ```
   short i = 100;
   short j = (short)100000; // 不加强转会报错，超出范围
   System.out.println(i+","+j);
   ------------------------------
   100,-31072
   ```

2. 常量相加再赋值，javac编译器会计算后再赋值给变量。但是，当有变量参与其中，将不再优化；

   ```
   final short a = 10;
   byte b = a + 5; // 编译通过，不会报错
   ```
































