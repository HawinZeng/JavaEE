# Http协议、TCP协议、IP协议 详解

## 一、Http协议

### 1.1、概念

超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种[网络协议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/328636)。所有的[WWW](https://baike.baidu.com/item/WWW)文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收`HTML`页面的方法。

1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调**“万维网协会（World Wide Web Consortium）”**和**“互联网工程工作小组（Internet Engineering Task Force ）“**共同合作研究，最终发布了一系列的[RFC](https://baike.baidu.com/item/RFC)，其中著名的RFC 2616定义了HTTP 1.1。

> **超文本:** 是用 **"超链接"** 的方法，将各种不同空间的文字信息组织在一起的网状文本；
>
> **超链接:** 就是指按内容链接。是指从一个网页指向一个目标的连接关系；

### 1.2、版本历史

**0.9**　已过时。只接受 GET 一种请求方法，没有在通讯中指定版本号，且不支持请求头。由于该版本不支持 POST 方法，所以客户端无法向服务器传递太多信息。

#### HTTP/1.0　

这是第一个在通讯中指定版本号的HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。

#### HTTP/1.1

当前版本。持久连接被默认采用，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

#### HTTP/2.0

HTTP/2 （原名HTTP/2.0）即超文本传输协议2.0，是下一代HTTP协议。是由互联网工程任务组（[IETF](https://baike.baidu.com/item/IETF)）的Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年http1.1发布后的首个更新。

HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上HTTP 2.0将只用于https://网址，而 http://网址将继续使用HTTP/1，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。DANE RFC6698允许域名管理员不通过第三方CA自行发行证书。

**[HTTP/2.0相关事项](md/HTTP2.0相关事项.md)**

### 1.3、各版本区别

- #### HTTP/1.1相较于 HTTP/1.0 协议的区别主要体现在：

  1. ##### 链接方式不同：

     ```
     1. HTTP/1.1支持长连接（PersistentConnection）,为默认使用。在同一个tcp的连接中可以传送多个HTTP请求和响应. 多个请求和响应可以重叠，多个请求和响应可以同时进行。持续链接主要是有个请求头`connection:keep-alive`；
     2. HTTP/1.0只保持短暂的连接；在1.0时的会话方式如下：
      	1）建立连接
      	2）发出请求信息
      	3）回送响应信息
      	4）关掉连接
     3. 由于长链接，Http/1.1 支持请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟；
     4. HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。
     ```

  2. #####  缓存处理(Http/1.1新增cache新特性)

     ```
     	在HTTP/1.0中，使用Expire头域来判断资源的fresh或stale，并使用条件请求（conditional request）来判断资源是否仍有效。例如，cache服务器通过If-Modified-Since头域向服务器验证资源的Last-Modefied头域是否有更新，源服务器可能返回304（Not Modified），则表明该对象仍有效；也可能返回200（OK）替换请求的Cache对象。
     
     此外，HTTP/1.0中还定义了Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。
     
     HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。
     
     HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化。
     
     为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为。
     
     Cache使用关键字索引在磁盘中缓存的对象，在HTTP/1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了支持这种内容协商机制(content negotiation mechanism)，HTTP/1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。
     ```

  3. ##### 带宽优化及网络连接的使用 [也可称：100(Continue) Status]

     ```
     HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。
     
     ```

  4. ##### 消息在网络中的发送的优化

     ```java
     // 1. Transfer-Encoding:chunked
     HTTP/1.1中引入了Chunked transfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
     
     
     // 2. Range 和 Content-Range(节约优化):
     HTTP1.1支持传送内容的一部分。比方说，当客户端已经有内容的一部分，为了节省带宽，可以只向服务器请求一部分。
      HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。
      
     // 3. 节省带宽资源的一个非常有效的做法就是压缩要传送的数据。
     Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。
     ```

  5. ##### 互联网地址的维护：Host域

     ```
     互联网上，一台台服务器是通过不同的IP来进行识别的。每台服务器上可以新建很多站点，您的网站程序就放在一个站点里面，然后在这个站点上绑定您的域名。所以一台服务器可以绑定很多个域名，也就是一个IP可以对应很多个域名，但是一个域名只能绑定到一个站点上，也就是对应一个IP。
     
     HTTP1.0中认为每台服务器绑定一个唯一的IP地址.因此,请求消息中的URL并没有传递主机名(hostname).
     HTTP1.1在Request消息头里头多了一个Host域,指定域名；
     
     由于HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。
     
     在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。
     ```

     > **同一服务器，部署多个web站点！然后又是如何指定访问的？**
     >
     > [服务器部署多个web站点详解](md/服务器部署多个web站点详解.md)

  6. ##### 其他新增项

     ```java
     // 1. HTTP1.1增加了OPTIONS,PUT, DELETE, TRACE, CONNECT这些Request方法.
     
     // 2. HTTP1.1 增加的新的status code：1xx 
     100 Continue
     101 Switching Protocols
     
     // 3. Entity Tags: 用于Cache.
     
     // 4. Quality Values: HTTP1.1多了个qvalue域
     qvalue = ( "0" ["." 0*3DIGIT ] )| ( "1" [ "." 0*3("0") ] )
     ```

- #### HTTP 2.0与1.1区别(详情参考[HTTP/2.0相关事项](md/HTTP2.0相关事项.md))

  ```java
  HTTP2.0使用多路复用技术(Multiplexing),多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
  "HTTP1.1在同一时间对于同一个域名的请求数量有限制，超过限制就会阻塞请求"。多路复用底层采用"增加二进制分帧层"的方法，使得不改变原来的语义、首部字段的情况下提高传输性能，降低延迟。
  二进制分帧将所有传输信息分割为更小的帧，用二进制进行编码，多个请求都在同一个TCP连接上完成，可以承载任意数量的双向数据流。HTTP/2更有效的使用TCP连接，得到性能上的提升。
  ```



## 二、TCP协议



























