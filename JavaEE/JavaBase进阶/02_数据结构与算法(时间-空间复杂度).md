# 数据结构与算法（时间复杂度/空间复杂度）

https://www.cnblogs.com/zknublx/p/5885840.html

https://blog.csdn.net/weixin_40123831/article/details/80398996

通常，对于一个给定的算法，我们要做 两项分析。第一是从数学上证明算法的正确性，这一步主要用到形式化证明的方法及相关推理模式，如循环不变式、数学归纳法等。而在证明算法是正确的基础上，第二部就是分析算法的时间复杂度。算法的时间复杂度反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能很好反映出算法的优劣与否。因此，作为程序员，掌握基本的算法时间复杂度分析方法是很有必要的。
       算法执行时间需通过依据该算法编制的程序在计算机上运行时所消耗的时间来度量。而度量一个程序的执行时间通常有两种方法。

**一、事后统计的方法**

​        这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。

**二、事前分析估算的方法**

​        因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。**因此人们常常采用事前分析估算的方法。**

在编写程序前，依据统计方法对算法进行估算。一个用高级语言编写的程序在计算机上运行时所消耗的时间取决于下列因素：

​      (1). 算法采用的策略、方法；(2). 编译产生的代码质量；(3). 问题的输入规模；(4).  机器执行指令的速度。

​     一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，则算法时间取决于两者的综合效果。为了便于比较同一个问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作的重复执行的次数作为算法的时间量度。

## 一、时间复杂度

**（1）时间频度** 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
**（2）时间复杂度** 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，**T(n)/f(n)**的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作**T(n)=Ｏ(f(n)),**称**Ｏ(f(n))** 为算法的渐进时间复杂度，简称时间复杂度。

​       另外，上面公式中用到的 Landau符号其实是由德国数论学家保罗·巴赫曼（Paul Bachmann）在其1892年的著作《解析数论》首先引入，由另一位德国数论学家艾德蒙·朗道（Edmund Landau）推广。**Landau符号的作用在于用简单的函数来描述复杂函数行为，给出一个上或下（确）界**。在计算算法复杂度时一般只用到大**O**符号，Landau符号体系中的小**o**符号、**Θ**符号等等比较不常用。这里的**O**，最初是用大写希腊字母，但现在都用大写英语字母**O**；小**o**符号也是用小写英语字母**o**，**Θ**符号则维持大写希腊字母**Θ**。
        **T (n) = Ο(f (n))** 表示存在一个常数C，使得在当n趋于正无穷时总有 T (n) ≤ C * f(n)。简单来说，就是T(n)在n趋于正无穷时最大也就跟f(n)差不多大。也就是说当n趋于正无穷时**T (n)**的上界是**C \* f(n)。**其虽然对f(n)没有规定，但是一般都是取尽可能简单的函数。例如，O(2*n*^2+n +1) = O (3*n*^2+n+3) = O (7*n^*2 + n) = **O ( n^2 )** ，一般都只用**O(n^2)**表示就可以了。注意到大O符号里隐藏着一个常数C，所以f(n)里一般不加系数。如果把T(n)当做一棵树，那么O(f(n))所表达的就是树干，只关心其中的主干，其他的细枝末节全都抛弃不管。
        在各种不同算法中，若算法中语句执行次数为一个常数，则时间复杂度为O(1),另外，在时间频度不相同时，时间复杂度有可能相同，如T(n)=*n*^2+3n+4与T(n)=4*n*^2+2n+1它们的频度不同，但时间复杂度相同，都为O(*n*^2)。 按数量级递增排列，常见的时间复杂度有：常数阶**O(1)**,对数阶**O(logn),2为底数,**线性阶**O(n),** 线性对数阶**O(nlogn),**平方阶**O(n^2)，**立方阶**O(n^3)**,...， k次方阶**O(n^k),**指数阶**O(2^n)。**随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。















